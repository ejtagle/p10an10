/*
 * drivers/input/touchscreen/zinitix.c
 *
 * Copyright (C) 2012 Eduardo José Tagle <ejtagle@tutopia.com>
 *  Reverse engineered from 2.6.36+ Shuttle N10 linux kernel
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */ 

//#define DEBUG

#include <linux/kobject.h>
#include <linux/module.h>
#include <linux/delay.h>
#include <linux/hrtimer.h>
#include <linux/i2c.h>
#include <asm/uaccess.h>
#include <linux/sysfs.h>
#include <linux/device.h>

#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/earlysuspend.h>
#include <linux/io.h>
#include <linux/cdev.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/input/zinitix.h>

#ifndef usleep
#define usleep(x) usleep_range(x,x)
#endif

#define MAX_TRACKED_POINTS 10

#define N10_TS_OFF_N 	TEGRA_GPIO_PA2  /* 1=powered */
#define N10_TS_RESET		TEGRA_GPIO_PD4  /* 0=reset */


#define DEFAULT_X_NODES 	20
#define DEFAULT_Y_NODES 	16
#define DEFAULT_X_RES		1280
#define DEFAULT_Y_RES		800

#define ESD_TIMEOUT 		3280


struct ts_rawpt {
	int x,y;		/* coordinates of the touch */
	int p;			/* Touch pressure */
};

struct ts_point {
	struct ts_rawpt data;	/* processed point data */
	int valid;				/* if point is valid or not */
};

struct zinitix_ts_ctx {
	struct i2c_client *client;
	struct input_dev *ts_input_dev;		// Touchscreen input device
	struct input_dev *kbd_input_dev;	// Iconic keyboard input device
	char ts_phys[32];
	char kbd_phys[32];
	
#ifdef CONFIG_HAS_EARLYSUSPEND	
	struct early_suspend early_suspend;
#endif

	struct work_struct  		 irq_work;	/* ISR workqueue */
	struct workqueue_struct *irq_wq;	
	
	struct delayed_work 		 esd_work;/* ESD lockup prevention */
	struct workqueue_struct *esd_wq; 
		
	int power_gpio;					/* power control gpio 	(1=powered) */
	int reset_gpio;					/* reset control gpio 	(0=reset) */
	int irq_gpio;					/* irq gpio */
	int icon_keycode[3];			/* Keycodes generated by the icons */
	
	u16 chiprev;					/* Chip revision */
	u16 xnodes;						/* X node number */
	u16 ynodes;						/* Y node number */
	u16 fwver;						/* fw version */
	u16 dataver;					/* data version */
	u16 eeinfo;						/* eeprom info */
	u16 intf;						/* interrupt flags */
	u16 cnf;						/* configuration */
	u16 maxx,maxy;					/* maximum X,Y */
	
	int use_esd_timer;				/* if we are using a timeout timer to detect lockups and reinit */
	
	struct ts_point pt[MAX_TRACKED_POINTS]; 		/* The list of points used right now - 10 finget tracking */
	u16    last_iconstate;			/* Icon state */
	int	   proximity_thresh;	/* Proximity threshold */
	int	   proximity_thresh2;	/* Proximity threshold squared */
	   
};

static struct zinitix_ts_ctx *gl_ts = NULL;

#define arr_nels(x) (sizeof(x)/sizeof(x[0]))

// --- Low level touchscreen Functions
static void zinitix_set_power(struct zinitix_ts_ctx* ctx, int power_on)
{
	dev_dbg(&ctx->client->dev,"zinitix_set_power: %d\n",power_on);
	if (!power_on) { /*powerdown */
		gpio_set_value(ctx->power_gpio,0);
	} else { /* powerup */
		gpio_set_value(ctx->power_gpio,1);
	}
}

static void zinitix_set_reset(struct zinitix_ts_ctx* ctx, int rst_enabled)
{
	dev_dbg(&ctx->client->dev,"zinitix_set_reset: %d\n",rst_enabled);
	if (!rst_enabled) { /* not reset */
		gpio_set_value(ctx->reset_gpio,1);
	} else { /* reset */
		gpio_set_value(ctx->reset_gpio,0);
	}
}

static void zinitix_powerdown(struct zinitix_ts_ctx* ctx)
{
	dev_dbg(&ctx->client->dev,"zinitix_powerdown\n");
	
	/* Set reset */
	zinitix_set_reset(ctx,1);
	
	/* Powerdown */
	zinitix_set_power(ctx, 0);
}

static void zinitix_powerup(struct zinitix_ts_ctx* ctx)
{
	dev_dbg(&ctx->client->dev,"zinitix_powerup\n");
	
	/* Just in case, power it down first*/
	zinitix_powerdown(ctx);
	msleep(10);
	
	/* Powerup */
	zinitix_set_power(ctx, 1);
	
	/* Power stabilization time */
	msleep(20);
	
	/* Release Reset */
	zinitix_set_reset(ctx,0);

	/* Boot time ...*/
	msleep(100);
}

static int zinitix_read_data(struct zinitix_ts_ctx* ctx,u8 pos, void* ans,int anslen)
{
	int res;
	char buf[1] = { pos };
	
	dev_dbg(&ctx->client->dev,"zinitix_read_data: pos:0x%02x\n", pos);
	
	res = i2c_master_send(ctx->client,buf,1);
	if (res != 1) {
		dev_err(&ctx->client->dev,"zinitix_read_data: failed to send pos\n");
		return -1;
	}
		
	usleep(50);
	
	res = i2c_master_recv(ctx->client,ans,anslen);
	if (res != anslen) {
		dev_err(&ctx->client->dev,"zinitix_read_data: failed to receive data\n");
	}

#ifdef DEBUG	
	else {
		char txt[512];
		char* pos = txt;
		int idx = 0;
		for (idx = 0; idx < anslen; idx ++) {
			sprintf(pos,"%02x ",((u8*)ans)[idx]);
			pos += 3;
		}
		*pos = 0;
		dev_dbg(&ctx->client->dev,"zinitix_read_data: got %d bytes: %s\n", anslen, txt);	
	}
#endif

	usleep(10); /* Recovery time */
	
	return res;
}

static int zinitix_read_reg(struct zinitix_ts_ctx* ctx,u8 pos)
{
	int res;
	u16 reg;
	char buf[1] = { pos };
	
	dev_dbg(&ctx->client->dev,"zinitix_read_reg: pos:0x%02x\n", pos);
	
	res = i2c_master_send(ctx->client,buf,1);
	if (res != 1) {
		dev_err(&ctx->client->dev,"zinitix_read_reg: failed to send pos\n");
		return -1;
	}
		
	usleep(50);
	
	res = i2c_master_recv(ctx->client,(char*)&reg,2);
	if (res != 2) {
		dev_err(&ctx->client->dev,"zinitix_read_reg: failed to receive data\n");
	}
#ifdef DEBUG	
	else {
		dev_dbg(&ctx->client->dev,"zinitix_read_reg: read: 0x%04x\n", reg);	
	}
#endif

	usleep(10); /* Recovery time */
	
	return reg;
}
	
static int zinitix_write_reg(struct zinitix_ts_ctx* ctx, u8 reg, u16 val)
{ 
	int res;
	dev_dbg(&ctx->client->dev,"zinitix_write_reg: pos:0x%02x, value:0x%04x\n", reg, val);
	
	res = i2c_smbus_write_word_data(ctx->client, reg, val);
	if (res < 0) {
		dev_err(&ctx->client->dev,"zinitix_write_reg: failed to send data\n");
	}
	
	usleep(10); /* Recovery time */
	
	return res;
}

static int zinitix_write_cmd(struct zinitix_ts_ctx* ctx, u8 val)
{
	int res;
	dev_dbg(&ctx->client->dev,"zinitix_write_cmd: 0x%02x\n", val);

	res = i2c_smbus_write_byte(ctx->client,val);
	if (res < 0) {
		dev_err(&ctx->client->dev,"zinitix_write_cmd: failed to send command\n");
	}

	usleep(10); /* Recovery time */
	
	return res;
}

static void start_esd_timer(struct zinitix_ts_ctx *ctx)
{
	dev_dbg(&ctx->client->dev,"start_esd_timer\n");
	queue_delayed_work(ctx->esd_wq, &ctx->esd_work,
				 msecs_to_jiffies(ESD_TIMEOUT)); 
}

static void stop_esd_timer(struct zinitix_ts_ctx *ctx)
{
	dev_dbg(&ctx->client->dev,"stop_esd_timer\n");
	cancel_delayed_work_sync(&ctx->esd_work);
}

static void stop_esd_timer_nowait(struct zinitix_ts_ctx *ctx)
{
	dev_dbg(&ctx->client->dev,"stop_esd_timer_nowait\n");
	cancel_delayed_work(&ctx->esd_work);
}

// Used to reinit in case of lockups... and resume from suspend
static int zinitix_reinit(struct zinitix_ts_ctx *ctx)
{
	int res,i;
	dev_dbg(&ctx->client->dev,"zinitix_reinit\n");
	
	// Write interrupt register
	res = zinitix_write_reg(ctx,0xF0,0);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to write interrupt register\n");
		return -1;
	}

	msleep(10);

	res = zinitix_write_cmd(ctx,3); 
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to send reset command [2]\n");
		return -1;
	}

	res = zinitix_write_reg(ctx,0x28,ctx->maxx);
	if (res < 0) 
		return -1;
	
	res = zinitix_write_reg(ctx,0x29,ctx->maxy);
	if (res < 0) 
		return -1;

	res = zinitix_write_reg(ctx,0x22,ctx->cnf);
	if (res < 0) 
		return -1;
		
	res = zinitix_write_cmd(ctx,6);
	if (res < 0) 
		return -1;

	res = zinitix_write_reg(ctx,0xF0,ctx->intf);
	if (res < 0) 
		return -1;

	for (i =0; i<10;i++) {
		res = zinitix_write_cmd(ctx,3); 
		if (res < 0) 
			return -1;
	}

	if (ctx->use_esd_timer) {
		res = zinitix_write_reg(ctx,0x35,0x3C); // ZINITIX_RAW_DATA_ESD_TIMER_INTERVAL
		if (res < 0) 
			return -1;
			
		start_esd_timer(ctx);
	}
	
	return 0;
}

static int zinitix_hardreset(struct zinitix_ts_ctx* ctx)
{
	dev_dbg(&ctx->client->dev,"zinitix_hardreset\n");
	
	gpio_direction_output(ctx->irq_gpio,0);
	msleep(50);
	gpio_direction_output(ctx->power_gpio,0);
	msleep(50);
	gpio_direction_output(ctx->power_gpio,1);
	msleep(500);
	gpio_direction_output(ctx->irq_gpio,1);
	msleep(50);
	gpio_direction_input(ctx->irq_gpio);
	
	return 0;
}

static int zinitix_init(struct zinitix_ts_ctx *ctx)
{
	int res,i;
	dev_dbg(&ctx->client->dev,"zinitix_init\n");

	// Maybe the touchscreen is just working...
	i=10;
	while (i > 0) {
		// Read interrupt mask
		res = zinitix_read_reg(ctx,0xF0);
		if (res >= 0) 
			break;
		i--;
	};

	if (!i) {
		// Hard reset the chip...
		zinitix_hardreset(ctx);
		
		// Maybe the touchscreen is just working...
		i=10;
		while (i > 0) {
			// Read interrupt mask
			res = zinitix_read_reg(ctx,0xF0);
			if (res >= 0) 
				break;
			i--;
		};
	}

	if (!i) {
		// Restart zinitix controller...
		zinitix_powerdown(ctx);
		
		// Give some rest time
		msleep(10);
		
		// And power it up!
		zinitix_powerup(ctx);
		
		// Try this several times, until it responds...
		i=100;
		while (i > 0) {
			// Read interrupt mask
			res = zinitix_read_reg(ctx,0xF0);
			if (res >= 0) 
				break;
			i--;
		};
	}
	
	if (!i) {
		dev_err(&ctx->client->dev,"failed to read interrupt mask\n");
		return -1;
	}
	
	ctx->intf = (u16)res;
	dev_dbg(&ctx->client->dev,"zinitix_init: interrupt mask: 0x%04x\n",ctx->intf);
	
	if ((ctx->intf & 0xF) != 0xF) {
		dev_err(&ctx->client->dev,"unexpected mask value\n");
		return -1;
	}

	// Write interrupt register
	res = zinitix_write_reg(ctx,0xF0,0);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to write interrupt register\n");
		return -1;
	}
	
	res = zinitix_write_cmd(ctx,0); 
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to send reset command [2]\n");
		return -1;
	}

	// Get chip revision ID
	res = zinitix_read_reg(ctx,0x13);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read chip revision\n");
		ctx->chiprev = 0;
	} else {
		ctx->chiprev = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: chip revision: %d\n",ctx->chiprev);
	}
	if (ctx->chiprev == 0) {
		dev_err(&ctx->client->dev,"unexpected chip revision\n");
		return -1;
	}
	
	// Get x node num
	res = zinitix_read_reg(ctx,0x20);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read X node number\n");
		ctx->xnodes = DEFAULT_X_NODES;
	} else {
		ctx->xnodes = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: X nodes: %d\n",ctx->xnodes);
	}
	
	// Get Y node num
	res = zinitix_read_reg(ctx,0x21);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read Y node number\n");
		ctx->ynodes = DEFAULT_Y_NODES;
	} else {
		ctx->ynodes = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: Y nodes: %d\n",ctx->ynodes);
	}

	// Get Firmware version
	res = zinitix_read_reg(ctx,0xC9);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read firmware version\n");
		ctx->fwver = 0;
	} else {
		ctx->fwver = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: firmware version: %d\n",ctx->fwver);
	}
	
	if (ctx->chiprev > 9 && ctx->fwver > 103) {
		// Get Touch reg data version
		res = zinitix_read_reg(ctx,0xAB);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read data version\n");
			ctx->dataver = 0;
		} else {
			ctx->dataver = (u16)res;
			dev_dbg(&ctx->client->dev,"zinitix_init: data version: %d\n",ctx->dataver);
		}
	} else {
		ctx->dataver = -1;
	}
	
	if (ctx->chiprev > 9 && ctx->fwver > 103) {
	
		// Get Touch reg data version
		res = zinitix_read_reg(ctx,0xAB);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read data version\n");
			ctx->dataver = 0;
		} else {
			ctx->dataver = (u16)res;
			dev_dbg(&ctx->client->dev,"zinitix_init: data version: %d\n",ctx->dataver);
		}

		// Get Touch EEPROM info
		res = zinitix_read_reg(ctx,0xAA);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read eeprom info\n");
			ctx->eeinfo = 0;
		} else {
			ctx->eeinfo = (u16)res;
			dev_dbg(&ctx->client->dev,"zinitix_init: eeinfo: 0x%04x\n",ctx->eeinfo);
		}
		
		if (ctx->eeinfo & 1) {

			res = zinitix_write_reg(ctx,0x10,0x7);		
			if (res < 0) 
				return -1;
			
			res = zinitix_write_cmd(ctx,6); 
			if (res < 0) 
				return -1;
			
			res = zinitix_write_cmd(ctx,0); 
			if (res < 0) 
				return -1;
			
			msleep(1);
			res = zinitix_write_cmd(ctx,3); 	
			if (res < 0) 
				return -1;
			
			i = 5;
			do {
				msleep(1000);

				// Get Touch EEPROM info
				res = zinitix_read_reg(ctx,0xAA);
				if (res < 0) {
					dev_err(&ctx->client->dev,"failed to read eeprom info\n");
					ctx->eeinfo = 0;
					break;
				} else {
					ctx->eeinfo = (u16)res;
					dev_dbg(&ctx->client->dev,"zinitix_init: eeinfo: 0x%04x\n",ctx->eeinfo);
				}
			} while (i-- > 0 && ctx->eeinfo & 1);

			res = zinitix_write_reg(ctx,0x10,0);
			if (res < 0) 
				return -1;
			
			res = zinitix_write_cmd(ctx,0); 
			if (res < 0) 
				return -1;
			
			res = zinitix_write_cmd(ctx,7); 
			if (res < 0) 
				return -1;
			
			msleep(1000);
			res = zinitix_write_cmd(ctx,0); 
			if (res < 0) 
				return -1;
			
		}
	}

	res = zinitix_write_reg(ctx,0x28,DEFAULT_X_RES);
	if (res < 0) 
		return -1;
	
	res = zinitix_write_reg(ctx,0x29,DEFAULT_Y_RES);
	if (res < 0) 
		return -1;
	
	
	// Get touch max X
	res = zinitix_read_reg(ctx,0x28);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read max X\n");
		ctx->maxx = DEFAULT_X_RES;
	} else {
		ctx->maxx = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: max X:%d\n",ctx->maxx);
	}

	
	// Get touch max Y
	res = zinitix_read_reg(ctx,0x29);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed to read max Y\n");
		ctx->maxy = DEFAULT_Y_RES;
	} else {
		ctx->maxy = (u16)res;
		dev_dbg(&ctx->client->dev,"zinitix_init: max Y:%d\n",ctx->maxy);
	}
	
	ctx->cnf = 0xA;
	if (ctx->chiprev > 9 && ctx->fwver > 116) {
		res = zinitix_write_reg(ctx,0x22,0xA);
		if (res < 0) 
			return -1;
		
		// Other configurations
		res = zinitix_read_reg(ctx,0x22);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read cfg\n");
		} else {
			ctx->cnf = (u16)res;
			dev_dbg(&ctx->client->dev,"zinitix_init: cfg 0x%04x\n",ctx->cnf);
		}
	}

	res = zinitix_write_reg(ctx,0x10,0);
	if (res < 0) 
		return -1;
	
	res = zinitix_write_cmd(ctx,6);
	if (res < 0) 
		return -1;
	
	res = zinitix_write_reg(ctx,0xF0,ctx->intf);
	if (res < 0) 
		return -1;

	
	for (i =0; i<10;i++) {
		res = zinitix_write_cmd(ctx,3); 
		if (res < 0) 
			return -1;
	}
	
	if (ctx->chiprev > 9 && ctx->fwver > 104) {	
		res = zinitix_write_reg(ctx,0x35,0x3C); // ZINITIX_RAW_DATA_ESD_TIMER_INTERVAL
		if (res < 0) 
			return -1;
	
		// init the touchscreen lockup timer 
		ctx->use_esd_timer = 1;		
	}
	
	return 0;
}

#if defined(CONFIG_PM) || defined(CONFIG_HAS_EARLYSUSPEND)
static int zinitix_ts_suspend(struct device *dev)
{
	int ret;
	struct i2c_client *client = to_i2c_client(dev);
	struct zinitix_ts_ctx *ctx = i2c_get_clientdata(client);

	dev_dbg(&ctx->client->dev,"zinitix_ts_suspend\n");
	
	// Cancel a pending isr process, if any and disable it
	disable_irq(client->irq);
	ret = cancel_work_sync(&ctx->irq_work);
	if (ret) /* if work was pending disable-count is now 2 */
		enable_irq(client->irq);

	// Disable the antilockup timer if used
	if (ctx->use_esd_timer) {
		stop_esd_timer(ctx);
	}

	if (ctx->use_esd_timer) {
		zinitix_write_reg(ctx,0x35,0); // ZINITIX_RAW_DATA_ESD_TIMER_INTERVAL
	}
	
	// Put the touchscreen to sleep...
	zinitix_write_reg(ctx,0xF0,0);
	usleep(100);
	zinitix_write_cmd(ctx,3); 
	zinitix_write_cmd(ctx,5); 
	
	// And finally, power it down
	zinitix_powerdown(ctx);
		
	// Done
	return 0;
}


static int zinitix_ts_resume(struct device *dev)
{
	int res;
	struct i2c_client *client = to_i2c_client(dev);
	struct zinitix_ts_ctx *ctx = i2c_get_clientdata(client);
	
	dev_dbg(&ctx->client->dev,"zinitix_ts_resume\n");

	// power touchscreen up
	zinitix_powerup(ctx);
	
	// wakeup touchscreen
	res = zinitix_write_cmd(ctx,1); 
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed wakeup\n");
	}
	
	// Reinit touchscreen
	res = zinitix_reinit(ctx);
	if (res < 0) {
		dev_err(&ctx->client->dev,"failed reinit\n");
	}
		
	enable_irq(client->irq);

	return 0;
}
#endif

static void zinitix_esd_work(struct work_struct *work)
{
	struct zinitix_ts_ctx *ctx = container_of((struct delayed_work*)work,
		struct zinitix_ts_ctx, esd_work); 
		
	int ret;
	dev_dbg(&ctx->client->dev,"zinitix_esd_work\n");

	// Cancel a pending isr process, if any and disable it
	disable_irq(ctx->client->irq);
	ret = cancel_work_sync(&ctx->irq_work);
	if (ret) /* if work was pending disable-count is now 2 */
		enable_irq(ctx->client->irq);
	
	/* Hard reset the touchscreen */
	zinitix_powerdown(ctx);
	msleep(10);
	zinitix_powerup(ctx);

	/* Reprogram it */
	ret = zinitix_reinit(ctx);
	if (ret < 0) {
		dev_err(&ctx->client->dev,"failed reinit\n");
	}

	// Enable ints
	enable_irq(ctx->client->irq);
}

static int dist2(int x1,int x2,int y1,int y2)
{
	int difx = x1 - x2;
	int dify = y1 - y2;
	return (difx * difx) + (dify * dify);
}

/* find closest point, or -1 if no points are near enough */
static int find_closest(struct ts_point* pts, int count, int x,int y,int maxdist2)
{
	int j;
	int dist = maxdist2;
	int pos = -1;
	for (j=0; j<count; j++) {
		if (pts[j].valid) {
			int tdist = dist2(pts[j].data.x,x,pts[j].data.y,y);
			if (tdist < dist) {
				dist = tdist;
				pos = j;
			}
		}
	}
	return pos;
}

/* Mark all points as invalid */
static void mark_allpts_asinvalid(struct ts_point* pts, int count)
{
	int i;
	for (i=0; i < count; i++) {
		pts[i].valid = 0;
	}
}

/* Find invalid pt */
static int find_invalid_pt(struct ts_point* pts, int count)
{
	int i;
	for (i=0; i < count; i++) {
		if (!pts[i].valid)
			return i;
	}
	return 0;
}

/* Init a point */
static void init_pt(struct ts_point* pt,struct ts_rawpt* p)
{
	pt->data.x = p->x;
	pt->data.y = p->y;
	pt->data.p = p->p;
	pt->valid = 1;
}

/* update point */
static void update_pt(struct ts_point* pt,struct ts_rawpt* p)
{
	pt->data.x = p->x;
	pt->data.y = p->y;
	pt->data.p = p->p;
	pt->valid = 1;
}

/* Called when fingers are detected */
static void update_fingers(struct zinitix_ts_ctx *ctx,struct ts_rawpt* p, int count)
{
	int i;
	int posd[MAX_TRACKED_POINTS];
	
	// Look for a point close enough trying all approachs
	for (i = 0; i < count; i++) {
		posd[i] = find_closest(&ctx->pt[0],arr_nels(ctx->pt),p[i].x,p[i].y,ctx->proximity_thresh2);
	}
	
	// Mark all points as invalid
	mark_allpts_asinvalid(&ctx->pt[0],arr_nels(ctx->pt));

	// Except the found ones
	for (i = 0; i < count; i++) {
		if (posd[i] >= 0)
			ctx->pt[posd[i]].valid = 1;
	}
	
	// If point was not found, find an empty slot and add it
	for (i = 0; i < count; i++) {
		if (posd[i] < 0) {
			int pos = find_invalid_pt(&ctx->pt[0],arr_nels(ctx->pt));
			init_pt(&ctx->pt[pos],&p[i]);
		} else {
			// Found it, just update the point info
			update_pt(&ctx->pt[posd[i]],&p[i]);
		}
	}
}

static void zinitix_readpoints(struct zinitix_ts_ctx *ctx)
{
	int ctr = 10,res;
	struct ts_rawpt p[MAX_TRACKED_POINTS];
	int idx = 0;

	dev_dbg(&ctx->client->dev,"zinitix_readpoints\n");
	
	// Stop touchscreen watchdog timer...
	if (ctx->use_esd_timer) {
		stop_esd_timer_nowait(ctx);
	}
	// (the esd timer could be running here...)
	
	// If real interrupt happened...
	dev_dbg(&ctx->client->dev,"zinitix_readpoints [2]\n");
	while (--ctr > 0 && gpio_get_value(ctx->irq_gpio) == 0) {

		u16 buf[0x20];
		u16 keybuf;
		int i;
		
		// Read point info
		res = zinitix_read_data(ctx,0x80,&buf,0x40);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read point info\n");
			zinitix_write_cmd(ctx,3);  // ACK int, just in case!
			break;
		}

		//  Go point by point, reporting it...
		idx = 0;
		for (i = 0; i < MAX_TRACKED_POINTS; i++) {
			u16 posx = buf[2 + 0 + (i*3)];
			u16 posy = buf[2 + 1 + (i*3)];
			u16 flags = buf[2 + 2 + (i*3)];
			
			if (flags & 0x100) {
				dev_dbg(&ctx->client->dev,"pt#%d: x:%d, y:%d\n",i,posx,posy);
				
				// Store detected points
				p[idx].x = posx;
				p[idx].y = posy;
				p[idx].p = 1;
				idx++;
			}
		}
		
		// Read icon info
		res = zinitix_read_reg(ctx,0x9A);
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed to read icon info\n");
			zinitix_write_cmd(ctx,3);  // ACK int, just in case!
			break;
		}
		keybuf = (u16) (res & 0x7);
		
		// Go key by key, reporting it...
		if (ctx->last_iconstate != keybuf) {
		
			u16 chg = ctx->last_iconstate ^ keybuf;
			
			for (i = 0; i < 3; i++) {
			
				// Key state changed...
				if ((chg >> i) & 1) {

					dev_dbg(&ctx->client->dev,"changed state of key %d to %d\n", ctx->icon_keycode[i], (keybuf >> i) & 1 );
					
					// Report the new state
					input_report_key(ctx->kbd_input_dev, ctx->icon_keycode[i], (keybuf >> i) & 1) ;
					input_sync(ctx->kbd_input_dev) ;
				}
			}
			ctx->last_iconstate = keybuf;
		}
		
		res = zinitix_write_cmd(ctx,3); 
		if (res < 0) {
			dev_err(&ctx->client->dev,"failed ack int\n");
		}
	}

	// Restart touchscreen watchdog timer...
	if (ctx->use_esd_timer) {
		start_esd_timer(ctx);
	}

#ifdef DEBUG
	dev_dbg(&ctx->client->dev,"got points: %d\n",idx);
	for (res = 0; res < idx; res ++) {
		dev_dbg(&ctx->client->dev,"[%d] - X:%d, Y:%d, P:%d\n", res,p[res].x,p[res].y,p[res].p);
	}
#endif
	
	//  Now, based on the number of detected fingers, process them.
	update_fingers(ctx,&p[0],idx);
	
	//  Finally, translate the processed points into linux events.
	idx = 0;
	for (res = 0; res < MAX_TRACKED_POINTS; res++) {
		if (ctx->pt[res].valid) {
		
			input_report_abs(ctx->ts_input_dev, ABS_MT_TRACKING_ID, res);
			input_report_abs(ctx->ts_input_dev, ABS_MT_TOUCH_MAJOR, ctx->pt[res].data.p);
			input_report_abs(ctx->ts_input_dev, ABS_MT_WIDTH_MAJOR, ctx->pt[res].data.p);
			input_report_abs(ctx->ts_input_dev, ABS_MT_POSITION_X , ctx->pt[res].data.x);
			input_report_abs(ctx->ts_input_dev, ABS_MT_POSITION_Y , ctx->pt[res].data.y);
			input_mt_sync(ctx->ts_input_dev);
			idx++;
		}
	}
	
	input_sync(ctx->ts_input_dev);	

#ifdef DEBUG
	dev_dbg(&ctx->client->dev,"processed points:\n");
	for (res = 0; res < MAX_TRACKED_POINTS; res ++) {
		dev_dbg(&ctx->client->dev,"[%d] - X:%d, Y:%d, P:%d, V:%d\n", res,ctx->pt[res].data.x,ctx->pt[res].data.y,ctx->pt[res].data.p,ctx->pt[res].valid);
	}
#endif
	
	// If nothing being touched...
	if(idx == 0)
	{
		input_report_key(ctx->ts_input_dev, BTN_TOUCH, 0);
		input_report_key(ctx->ts_input_dev, ABS_MT_TOUCH_MAJOR, 0);
		input_mt_sync(ctx->ts_input_dev);
		input_sync(ctx->ts_input_dev);	
	} 

	// Finally, reenable irqs
	enable_irq(ctx->client->irq);
}

static void zinitix_irq_work(struct work_struct *work)
{
	struct zinitix_ts_ctx *ctx = container_of(work, struct zinitix_ts_ctx, irq_work);
	zinitix_readpoints(ctx);
}

static irqreturn_t zinitix_irq_handler(int irq, void *dev_id)
{
	struct zinitix_ts_ctx *ctx = dev_id;

	disable_irq_nosync(ctx->client->irq);
	queue_work(ctx->irq_wq, &ctx->irq_work);
	return IRQ_HANDLED;
}

///////////////////////////////////////////////////////////////////////////////////////

static ssize_t threshold_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct zinitix_ts_ctx *ctx = gl_ts;

	return sprintf(buf, "%d\n", ctx->proximity_thresh);
}

static ssize_t threshold_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	struct zinitix_ts_ctx *ctx = gl_ts;
	long val = 0;
	int error = strict_strtol(buf,10,&val);
	if (error) 
		return error;
	
	if (val > 1024) 
		val = 1024;
	
	ctx->proximity_thresh = buf[0] - '0';
	ctx->proximity_thresh2 = ctx->proximity_thresh * ctx->proximity_thresh;

	return count;
}

static DEVICE_ATTR(threshold, 0664, threshold_show, threshold_store);

#ifdef CONFIG_HAS_EARLYSUSPEND
static void zinitix_ts_early_suspend(struct early_suspend *h);
static void zinitix_ts_late_resume(struct early_suspend *h);
#endif

///////////////////////////////////////////////////////////////////////////////////////
static int zinitix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	struct zinitix_ts_ctx *ctx;
	struct zinitix_platform_data *pdata = client->dev.platform_data;
	int ret = 0;
	
	dev_info(&client->dev,"zinitix touchscreen Driver\n");

	if (!pdata) {
		dev_err(&client->dev,"no platform data\n");
		return -EIO;
	}
	
	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		dev_err(&client->dev,"need I2C_FUNC_I2C\n");
		return -EIO;
	}

	ctx = kzalloc(sizeof(struct zinitix_ts_ctx), GFP_KERNEL);
	if (!ctx) {
		dev_err(&client->dev,"failed memory allocation\n");
		return -ENOMEM;
	}
	gl_ts = ctx;
	
	i2c_set_clientdata(client, ctx);
	ctx->client = client;
	
	// Fill in default values
	ctx->power_gpio = pdata->power_gpio;					/* power control gpio 	(1=powered) */
	ctx->reset_gpio = pdata->reset_gpio;					/* reset control gpio 	(0=reset) */
	ctx->irq_gpio = pdata->irq_gpio;						/* irq gpio */
	memcpy(ctx->icon_keycode,pdata->icon_keycode,sizeof(ctx->icon_keycode)); /* The keycodes generated by the icons */

	ctx->proximity_thresh = 50;
	ctx->proximity_thresh2 = ctx->proximity_thresh * ctx->proximity_thresh;

	// Allocate gpios...
	gpio_request(ctx->power_gpio,"zinitix_power");
	gpio_request(ctx->reset_gpio,"zinitix_reset");
	gpio_request(ctx->irq_gpio,"zinitix_irq");

	// Properly set the direction and values...
	gpio_direction_output(ctx->power_gpio,1);
	gpio_direction_output(ctx->reset_gpio,1);
	gpio_direction_input(ctx->irq_gpio);

	// Hard reset the chip...
	zinitix_hardreset(ctx);

	// Try to init the capacitive sensor
	if(zinitix_init(ctx)) {
		dev_err(&client->dev,"not detected or in firmware upgrade mode.\n");
		ret = -ENODEV;
		goto error_not_found;
	}
	
	// Prepare the input context
	ctx->ts_input_dev = input_allocate_device();
	if (ctx->ts_input_dev == NULL) {
		ret = -ENOMEM;
		dev_err(&client->dev,"failed to allocate ts input device\n");
		goto err_input_alloc;
	}
	
	// Fill in information
	input_set_drvdata(ctx->ts_input_dev, ctx);
	snprintf(ctx->ts_phys, sizeof(ctx->ts_phys), "%s/input0", dev_name(&client->dev));
	ctx->ts_input_dev->name = "zinitix";
	ctx->ts_input_dev->phys = ctx->ts_phys;
	ctx->ts_input_dev->dev.parent = &client->dev;
	ctx->ts_input_dev->id.bustype = BUS_I2C;
	ctx->ts_input_dev->id.vendor = 0x0001;
	ctx->ts_input_dev->id.product = 0x0001;
	ctx->ts_input_dev->id.version = 0x0100;
	
	// And capabilities
//	set_bit(EV_SYN, ctx->ts_input_dev->evbit);
//	set_bit(EV_KEY, ctx->ts_input_dev->evbit);
	set_bit(EV_ABS, ctx->ts_input_dev->evbit);
	set_bit(BTN_TOUCH, ctx->ts_input_dev->keybit);

	input_set_abs_params(ctx->ts_input_dev, ABS_MT_TOUCH_MAJOR, 0, 15, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_MT_POSITION_X, 0, ctx->maxx, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_MT_POSITION_Y, 0, ctx->maxy, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_MT_TRACKING_ID, 0, (MAX_TRACKED_POINTS- 1), 0, 0);
	
	input_set_abs_params(ctx->ts_input_dev, ABS_X, 0, ctx->maxx, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_Y, 0, ctx->maxy, 0, 0);
	input_set_abs_params(ctx->ts_input_dev, ABS_PRESSURE, 0, 15, 0, 0);

	ret = input_register_device(ctx->ts_input_dev);
	if (ret) {
		ret = -ENOMEM;
		dev_err(&client->dev,"unable to register %s input device\n", ctx->ts_input_dev->name);
		goto err_could_not_register;
	}

	ctx->kbd_input_dev = input_allocate_device();
	if (!ctx->kbd_input_dev) {
		ret = -ENOMEM;
		dev_err(&client->dev,"failed to allocate kbd input device\n");
		goto err_input_alloc2;
	}

	input_set_drvdata(ctx->kbd_input_dev, ctx);
	snprintf(ctx->kbd_phys, sizeof(ctx->kbd_phys), "%s-kbd/input0", dev_name(&client->dev));
	ctx->kbd_input_dev->name = "zinitix-kbd";
	ctx->kbd_input_dev->phys = ctx->kbd_phys;
	ctx->kbd_input_dev->dev.parent = &client->dev;
	ctx->kbd_input_dev->id.bustype = BUS_I2C;
	ctx->kbd_input_dev->id.vendor = 0x0001;
	ctx->kbd_input_dev->id.product = 0x0001;
	ctx->kbd_input_dev->id.version = 0x0100;

	set_bit(EV_KEY,ctx->kbd_input_dev->evbit) ;
	set_bit(ctx->icon_keycode[0],ctx->kbd_input_dev->keybit) ;
	set_bit(ctx->icon_keycode[1],ctx->kbd_input_dev->keybit) ;
	set_bit(ctx->icon_keycode[2],ctx->kbd_input_dev->keybit) ;
	
	ret = input_register_device(ctx->kbd_input_dev);
	if (ret) {
		ret = -ENOMEM;
		dev_err(&client->dev,"unable to register %s input device\n", ctx->ts_input_dev->name);
		goto err_could_not_register2;
	}
	
#ifdef CONFIG_HAS_EARLYSUSPEND
	ctx->early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING - 1;
	ctx->early_suspend.suspend = zinitix_ts_early_suspend;
	ctx->early_suspend.resume = zinitix_ts_late_resume;
	register_early_suspend(&ctx->early_suspend);
#endif
	
	ctx->irq_wq = create_singlethread_workqueue("zinitix_irq_wq");
	if (!ctx->irq_wq) {
		ret = -ENOMEM;
		dev_err(&client->dev,"unable to allocate irq workqueue\n");	
		goto err_alloc_wq;
	}
	
	INIT_WORK(&ctx->irq_work, zinitix_irq_work);
	
	ctx->esd_wq = create_singlethread_workqueue("zinitix_esd_wq");
	if (!ctx->esd_wq) {
		ret = -ENOMEM;
		dev_err(&client->dev, "could not allocate esd workqueue\n");
		goto err_ps_register;
	}
	INIT_DELAYED_WORK(&ctx->esd_work, zinitix_esd_work); 
	
	ret = request_irq(client->irq, zinitix_irq_handler, IRQF_TRIGGER_LOW, client->name, ctx);
	if (ret) {
		dev_err(&client->dev, "request_irq failed\n");
		goto err_irq_reg_fail;
	}

    // Create attributes
    ret = device_create_file(&ctx->ts_input_dev->dev, &dev_attr_threshold);
	if (ret) {
		ret = -ENOMEM;
		dev_err(&client->dev, "error creating threshold attribute\n");
		goto err_attr_create;
	}
	
	// Just in case, reinit the controller, starting the ESD timer if required
	zinitix_reinit(ctx);
	
	dev_info(&client->dev,"touchscreen driver loaded\n");
	return 0;
	
err_attr_create:
	free_irq(client->irq,ctx);
	
err_irq_reg_fail:

	destroy_workqueue(ctx->esd_wq);
	
err_ps_register:
	destroy_workqueue(ctx->irq_wq);

err_alloc_wq:

#ifdef CONFIG_HAS_EARLYSUSPEND	
	unregister_early_suspend(&ctx->early_suspend);
#endif


err_could_not_register2:
	input_free_device(ctx->kbd_input_dev);
	
err_input_alloc2:

err_could_not_register:
	input_free_device(ctx->ts_input_dev);
	
err_input_alloc:
error_not_found:

	gpio_free(ctx->power_gpio);
	gpio_free(ctx->reset_gpio);
	gpio_free(ctx->irq_gpio);

	i2c_set_clientdata(client, NULL);
	kfree(ctx);

	return ret;

}

static int zinitix_ts_remove(struct i2c_client *client)
{
	int ret;
	struct zinitix_ts_ctx *ctx = i2c_get_clientdata(client);

	ctx->use_esd_timer = 0;
	disable_irq(ctx->client->irq);
	ret = cancel_work_sync(&ctx->irq_work);
	if (ret) /* if work was pending disable-count is now 2 */
		enable_irq(ctx->client->irq);
	
	zinitix_write_reg(ctx,0x35,0); // ZINITIX_RAW_DATA_ESD_TIMER_INTERVAL
	stop_esd_timer(ctx);
	
	/* Hard reset the touchscreen */
	zinitix_powerdown(ctx);
	
	enable_irq(ctx->client->irq);
	
	free_irq(ctx->client->irq,ctx);
	
	destroy_workqueue(ctx->irq_wq);
	destroy_workqueue(ctx->esd_wq);
	
#ifdef CONFIG_HAS_EARLYSUSPEND	
	unregister_early_suspend(&ctx->early_suspend);
#endif
	
	input_free_device(ctx->kbd_input_dev);
	input_free_device(ctx->ts_input_dev);

	gpio_free(ctx->power_gpio);
	gpio_free(ctx->reset_gpio);
	gpio_free(ctx->irq_gpio);

	i2c_set_clientdata(client, NULL);
	kfree(ctx);
	
	return 0;
}

#ifdef CONFIG_PM
static const struct dev_pm_ops zinitix_pm_ops = {
	.suspend	= zinitix_ts_suspend,
	.resume	= zinitix_ts_resume,
};
#endif

#ifdef CONFIG_HAS_EARLYSUSPEND
static void zinitix_ts_early_suspend(struct early_suspend *h)
{
	struct zinitix_ts_ctx *ctx = container_of(h, struct zinitix_ts_ctx, early_suspend);
	zinitix_ts_suspend(&ctx->client->dev);
}

static void zinitix_ts_late_resume(struct early_suspend *h)
{
	struct zinitix_ts_ctx *ctx = container_of(h, struct zinitix_ts_ctx, early_suspend);
	zinitix_ts_resume(&ctx->client->dev);
}
#endif


static const struct i2c_device_id zinitix_ts_id[] = {
	{ "zinitix", 0 },
	{}
};

static struct i2c_driver zinitix_ts_driver = {
	.driver = {
		.name	= "zinitix",
		.owner  = THIS_MODULE,
#if !defined(CONFIG_HAS_EARLYSUSPEND) && defined(CONFIG_PM)
		.pm 	= &zinitix_pm_ops,
#endif
	},
	.probe		= zinitix_ts_probe,
	.remove		= zinitix_ts_remove,
	.id_table	= zinitix_ts_id,
};

static int __devinit zinitix_ts_init(void)
{
	pr_info("zinitix touchscreen driver\n");
	return i2c_add_driver(&zinitix_ts_driver);
}

static void __exit zinitix_ts_exit(void)
{
	i2c_del_driver(&zinitix_ts_driver);
}

module_init(zinitix_ts_init);
module_exit(zinitix_ts_exit);

MODULE_AUTHOR("Eduardo José Tagle <ejtagle@tutopia.com>");
MODULE_DESCRIPTION("zinitix Touchscreen Driver");
MODULE_LICENSE("GPL");
